#!/usr/bin/env bash

set -e

function _filter {
  declare -a allowed_fns
  allowed_fns=(
    # arithmetic
    even
    odd

    # comparison
    eq
    equal
    ne
    not_eq
    not_equals
    ge
    greater_equals
    gt
    greater_than
    le
    less_equals
    lt
    less_than

    # file_and_dir
    is_dir
    is_link
    is_file
    is_executable
    exists
    has_ext

    # logical
    non_empty

    # string
    contains
    starts_with
    ends_with
  )

  local fn_arg="$1"
  shift
  local args="$*"

  if [[ ! "${allowed_fns[*]}" == *"${fn_arg}"* ]]; then
    echo "Error: '$fn_arg' is not a valid operation for filter" >&2
    echo "" >&2
    echo "Available filter operations:" >&2
    echo "  Arithmetic: even, odd" >&2
    echo "  Comparison: eq, ne, gt, lt, ge, le" >&2
    echo "  String:     contains, starts_with, ends_with" >&2
    echo "  File:       is_file, is_dir, is_link, exists, has_ext" >&2
    echo "  Logical:    non_empty" >&2
    echo "" >&2
    echo "For help: filter --help" >&2
    echo "Note: Filter operations are restricted for security" >&2
    exit 1
  fi

  # If empty input exit with 1
  if test -t 0; then
    exit 1
  fi

  # Change IFS to preserve whitespace in filenames
  local old_ifs=$IFS
  IFS=''

  local has_input=false
  local filter_res
  while read -r line; do
    has_input=true
    # Call function directly without subshell
    filter_res=$($fn_arg "$line" "$args")
    if [ "$filter_res" == "true" ]; then
      printf "%s\n" "$line"
    fi
  done < /dev/stdin

  # If no input was provided, exit with 1
  if [ "$has_input" = "false" ]; then
    exit 1
  fi

  IFS=$old_ifs
}

export -f _filter
